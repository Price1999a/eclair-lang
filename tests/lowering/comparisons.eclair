// RUN: split-file %s %t

// RUN: %eclair compile --emit ra-transformed %t/program.eclair > %t/actual_ra.out
// RUN: diff %t/expected_ra.out %t/actual_ra.out

// RUN: %eclair compile --emit eir %t/program.eclair > %t/actual_eir.out
// RUN: diff %t/expected_eir.out %t/actual_eir.out

// RUN: %eclair compile --emit llvm %t/program.eclair > %t/actual_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "define.*@eclair_program_run" > %t/actual_llvm_snippet.out
// RUN: diff %t/expected_llvm.out %t/actual_llvm_snippet.out

//--- program.eclair
@def fact1(u32, u32) input.
@def fact2(u32, u32) output.

fact2(x, 1) :-
  z = x,
  fact1(x, z),
  y = 123,
  fact1(y, x).

fact2(x, y) :-
  123 = x,
  fact1(y, x).

fact2(x, y) :-
  123 < x,
  123 <= x,
  123 > x,
  123 >= x,
  123 != x,
  fact1(y, x).

//--- expected_ra.out
search fact1 as fact10 do
  if 123 < fact10[1] do
    if 123 <= fact10[1] do
      if 123 > fact10[1] do
        if 123 >= fact10[1] do
          if 123 != fact10[1] do
            project (fact10[1], fact10[0]) into fact2
search fact1 as fact10 where (123 = fact10[1]) do
  project (fact10[1], fact10[0]) into fact2
search fact1 as fact10 do
  if fact10[1] = fact10[0] do
    search fact1 as fact11 where (fact11[0] = 123 and fact10[0] = fact11[1]) do
      project (fact10[0], 1) into fact2
//--- expected_eir.out
declare_type Program
{
  symbol_table
  fact1 btree(num_columns=2, index=[1,0], block_size=256, search_type=linear)
  fact2 btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
}

export fn eclair_program_init() -> *Program
{
  program = heap_allocate_program
  symbol_table.init(program.0)
  fact1.init_empty(program.1)
  fact2.init_empty(program.2)
  symbol_table.insert(program.0, fact1)
  symbol_table.insert(program.0, fact2)
  return program
}

export fn eclair_program_destroy(*Program) -> Void
{
  symbol_table.destroy(FN_ARG[0].0)
  fact1.destroy(FN_ARG[0].1)
  fact2.destroy(FN_ARG[0].2)
  free_program(FN_ARG[0])
}

export fn eclair_program_run(*Program) -> Void
{
  lower_bound_value = fact1.stack_allocate Value
  upper_bound_value = fact1.stack_allocate Value
  lower_bound_value.0 = 0
  lower_bound_value.1 = 0
  upper_bound_value.0 = 4294967295
  upper_bound_value.1 = 4294967295
  begin_iter = fact1.stack_allocate Iter
  end_iter = fact1.stack_allocate Iter
  fact1.iter_lower_bound(FN_ARG[0].1, lower_bound_value, begin_iter)
  fact1.iter_upper_bound(FN_ARG[0].1, upper_bound_value, end_iter)
  loop
  {
    condition = fact1.iter_is_equal(begin_iter, end_iter)
    if (condition)
    {
      goto range_query.end
    }
    current = fact1.iter_current(begin_iter)
    condition_1 = (123 < current.1)
    if (condition_1)
    {
      condition_2 = (123 <= current.1)
      if (condition_2)
      {
        condition_3 = (123 > current.1)
        if (condition_3)
        {
          condition_4 = (123 >= current.1)
          if (condition_4)
          {
            condition_5 = (123 != current.1)
            if (condition_5)
            {
              value = fact2.stack_allocate Value
              value.0 = current.1
              value.1 = current.0
              fact2.insert(FN_ARG[0].2, value)
            }
          }
        }
      }
    }
    fact1.iter_next(begin_iter)
  }
  range_query.end:
  lower_bound_value_1 = fact1.stack_allocate Value
  upper_bound_value_1 = fact1.stack_allocate Value
  lower_bound_value_1.0 = 0
  lower_bound_value_1.1 = 123
  upper_bound_value_1.0 = 4294967295
  upper_bound_value_1.1 = 123
  begin_iter_1 = fact1.stack_allocate Iter
  end_iter_1 = fact1.stack_allocate Iter
  fact1.iter_lower_bound(FN_ARG[0].1, lower_bound_value_1, begin_iter_1)
  fact1.iter_upper_bound(FN_ARG[0].1, upper_bound_value_1, end_iter_1)
  loop
  {
    condition_6 = fact1.iter_is_equal(begin_iter_1, end_iter_1)
    if (condition_6)
    {
      goto range_query.end_1
    }
    current_1 = fact1.iter_current(begin_iter_1)
    value_1 = fact2.stack_allocate Value
    value_1.0 = current_1.1
    value_1.1 = current_1.0
    fact2.insert(FN_ARG[0].2, value_1)
    fact1.iter_next(begin_iter_1)
  }
  range_query.end_1:
  lower_bound_value_2 = fact1.stack_allocate Value
  upper_bound_value_2 = fact1.stack_allocate Value
  lower_bound_value_2.0 = 0
  lower_bound_value_2.1 = 0
  upper_bound_value_2.0 = 4294967295
  upper_bound_value_2.1 = 4294967295
  begin_iter_2 = fact1.stack_allocate Iter
  end_iter_2 = fact1.stack_allocate Iter
  fact1.iter_lower_bound(FN_ARG[0].1, lower_bound_value_2, begin_iter_2)
  fact1.iter_upper_bound(FN_ARG[0].1, upper_bound_value_2, end_iter_2)
  loop
  {
    condition_7 = fact1.iter_is_equal(begin_iter_2, end_iter_2)
    if (condition_7)
    {
      goto range_query.end_2
    }
    current_2 = fact1.iter_current(begin_iter_2)
    condition_8 = (current_2.1 == current_2.0)
    if (condition_8)
    {
      lower_bound_value_3 = fact1.stack_allocate Value
      upper_bound_value_3 = fact1.stack_allocate Value
      lower_bound_value_3.0 = 123
      lower_bound_value_3.1 = current_2.0
      upper_bound_value_3.0 = 123
      upper_bound_value_3.1 = current_2.0
      begin_iter_3 = fact1.stack_allocate Iter
      end_iter_3 = fact1.stack_allocate Iter
      fact1.iter_lower_bound(FN_ARG[0].1, lower_bound_value_3, begin_iter_3)
      fact1.iter_upper_bound(FN_ARG[0].1, upper_bound_value_3, end_iter_3)
      loop
      {
        condition_9 = fact1.iter_is_equal(begin_iter_3, end_iter_3)
        if (condition_9)
        {
          goto range_query.end_3
        }
        current_3 = fact1.iter_current(begin_iter_3)
        value_2 = fact2.stack_allocate Value
        value_2.0 = current_2.0
        value_2.1 = 1
        fact2.insert(FN_ARG[0].2, value_2)
        fact1.iter_next(begin_iter_3)
      }
      range_query.end_3:
    }
    fact1.iter_next(begin_iter_2)
  }
  range_query.end_2:
}
//--- expected_llvm.out
define external ccc void @eclair_program_run(%program* %arg_0) "wasm-export-name"="eclair_program_run" {
start:
  %0 = alloca [2 x i32], i32 1
  %1 = alloca [2 x i32], i32 1
  %2 = getelementptr [2 x i32], [2 x i32]* %0, i32 0, i32 0
  store i32 0, i32* %2
  %3 = getelementptr [2 x i32], [2 x i32]* %0, i32 0, i32 1
  store i32 0, i32* %3
  %4 = getelementptr [2 x i32], [2 x i32]* %1, i32 0, i32 0
  store i32 4294967295, i32* %4
  %5 = getelementptr [2 x i32], [2 x i32]* %1, i32 0, i32 1
  store i32 4294967295, i32* %5
  %6 = alloca %btree_iterator_t_0, i32 1
  %7 = alloca %btree_iterator_t_0, i32 1
  %8 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_lower_bound_0(%btree_t_0* %8, [2 x i32]* %0, %btree_iterator_t_0* %6)
  %9 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_upper_bound_0(%btree_t_0* %9, [2 x i32]* %1, %btree_iterator_t_0* %7)
  br label %loop_0
loop_0:
  %10 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %6, %btree_iterator_t_0* %7)
  br i1 %10, label %if_0, label %end_if_0
if_0:
  br label %range_query.end
end_if_0:
  %11 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %6)
  %12 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %13 = load i32, i32* %12
  %14 = icmp ult i32 123, %13
  br i1 %14, label %if_1, label %end_if_5
if_1:
  %15 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %16 = load i32, i32* %15
  %17 = icmp ule i32 123, %16
  br i1 %17, label %if_2, label %end_if_4
if_2:
  %18 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %19 = load i32, i32* %18
  %20 = icmp ugt i32 123, %19
  br i1 %20, label %if_3, label %end_if_3
if_3:
  %21 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %22 = load i32, i32* %21
  %23 = icmp uge i32 123, %22
  br i1 %23, label %if_4, label %end_if_2
if_4:
  %24 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %25 = load i32, i32* %24
  %26 = icmp ne i32 123, %25
  br i1 %26, label %if_5, label %end_if_1
if_5:
  %27 = alloca [2 x i32], i32 1
  %28 = getelementptr [2 x i32], [2 x i32]* %27, i32 0, i32 0
  %29 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 1
  %30 = load i32, i32* %29
  store i32 %30, i32* %28
  %31 = getelementptr [2 x i32], [2 x i32]* %27, i32 0, i32 1
  %32 = getelementptr [2 x i32], [2 x i32]* %11, i32 0, i32 0
  %33 = load i32, i32* %32
  store i32 %33, i32* %31
  %34 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %35 = call ccc i1 @btree_insert_value_1(%btree_t_1* %34, [2 x i32]* %27)
  br label %end_if_1
end_if_1:
  br label %end_if_2
end_if_2:
  br label %end_if_3
end_if_3:
  br label %end_if_4
end_if_4:
  br label %end_if_5
end_if_5:
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %6)
  br label %loop_0
range_query.end:
  %36 = alloca [2 x i32], i32 1
  %37 = alloca [2 x i32], i32 1
  %38 = getelementptr [2 x i32], [2 x i32]* %36, i32 0, i32 0
  store i32 0, i32* %38
  %39 = getelementptr [2 x i32], [2 x i32]* %36, i32 0, i32 1
  store i32 123, i32* %39
  %40 = getelementptr [2 x i32], [2 x i32]* %37, i32 0, i32 0
  store i32 4294967295, i32* %40
  %41 = getelementptr [2 x i32], [2 x i32]* %37, i32 0, i32 1
  store i32 123, i32* %41
  %42 = alloca %btree_iterator_t_0, i32 1
  %43 = alloca %btree_iterator_t_0, i32 1
  %44 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_lower_bound_0(%btree_t_0* %44, [2 x i32]* %36, %btree_iterator_t_0* %42)
  %45 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_upper_bound_0(%btree_t_0* %45, [2 x i32]* %37, %btree_iterator_t_0* %43)
  br label %loop_1
loop_1:
  %46 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %42, %btree_iterator_t_0* %43)
  br i1 %46, label %if_6, label %end_if_6
if_6:
  br label %range_query.end_1
end_if_6:
  %47 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %42)
  %48 = alloca [2 x i32], i32 1
  %49 = getelementptr [2 x i32], [2 x i32]* %48, i32 0, i32 0
  %50 = getelementptr [2 x i32], [2 x i32]* %47, i32 0, i32 1
  %51 = load i32, i32* %50
  store i32 %51, i32* %49
  %52 = getelementptr [2 x i32], [2 x i32]* %48, i32 0, i32 1
  %53 = getelementptr [2 x i32], [2 x i32]* %47, i32 0, i32 0
  %54 = load i32, i32* %53
  store i32 %54, i32* %52
  %55 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %56 = call ccc i1 @btree_insert_value_1(%btree_t_1* %55, [2 x i32]* %48)
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %42)
  br label %loop_1
range_query.end_1:
  %57 = alloca [2 x i32], i32 1
  %58 = alloca [2 x i32], i32 1
  %59 = getelementptr [2 x i32], [2 x i32]* %57, i32 0, i32 0
  store i32 0, i32* %59
  %60 = getelementptr [2 x i32], [2 x i32]* %57, i32 0, i32 1
  store i32 0, i32* %60
  %61 = getelementptr [2 x i32], [2 x i32]* %58, i32 0, i32 0
  store i32 4294967295, i32* %61
  %62 = getelementptr [2 x i32], [2 x i32]* %58, i32 0, i32 1
  store i32 4294967295, i32* %62
  %63 = alloca %btree_iterator_t_0, i32 1
  %64 = alloca %btree_iterator_t_0, i32 1
  %65 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_lower_bound_0(%btree_t_0* %65, [2 x i32]* %57, %btree_iterator_t_0* %63)
  %66 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_upper_bound_0(%btree_t_0* %66, [2 x i32]* %58, %btree_iterator_t_0* %64)
  br label %loop_2
loop_2:
  %67 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %63, %btree_iterator_t_0* %64)
  br i1 %67, label %if_7, label %end_if_7
if_7:
  br label %range_query.end_2
end_if_7:
  %68 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %63)
  %69 = getelementptr [2 x i32], [2 x i32]* %68, i32 0, i32 1
  %70 = load i32, i32* %69
  %71 = getelementptr [2 x i32], [2 x i32]* %68, i32 0, i32 0
  %72 = load i32, i32* %71
  %73 = icmp eq i32 %70, %72
  br i1 %73, label %if_8, label %end_if_9
if_8:
  %74 = alloca [2 x i32], i32 1
  %75 = alloca [2 x i32], i32 1
  %76 = getelementptr [2 x i32], [2 x i32]* %74, i32 0, i32 0
  store i32 123, i32* %76
  %77 = getelementptr [2 x i32], [2 x i32]* %74, i32 0, i32 1
  %78 = getelementptr [2 x i32], [2 x i32]* %68, i32 0, i32 0
  %79 = load i32, i32* %78
  store i32 %79, i32* %77
  %80 = getelementptr [2 x i32], [2 x i32]* %75, i32 0, i32 0
  store i32 123, i32* %80
  %81 = getelementptr [2 x i32], [2 x i32]* %75, i32 0, i32 1
  %82 = getelementptr [2 x i32], [2 x i32]* %68, i32 0, i32 0
  %83 = load i32, i32* %82
  store i32 %83, i32* %81
  %84 = alloca %btree_iterator_t_0, i32 1
  %85 = alloca %btree_iterator_t_0, i32 1
  %86 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_lower_bound_0(%btree_t_0* %86, [2 x i32]* %74, %btree_iterator_t_0* %84)
  %87 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_upper_bound_0(%btree_t_0* %87, [2 x i32]* %75, %btree_iterator_t_0* %85)
  br label %loop_3
loop_3:
  %88 = call ccc i1 @btree_iterator_is_equal_0(%btree_iterator_t_0* %84, %btree_iterator_t_0* %85)
  br i1 %88, label %if_9, label %end_if_8
if_9:
  br label %range_query.end_3
end_if_8:
  %89 = call ccc [2 x i32]* @btree_iterator_current_0(%btree_iterator_t_0* %84)
  %90 = alloca [2 x i32], i32 1
  %91 = getelementptr [2 x i32], [2 x i32]* %90, i32 0, i32 0
  %92 = getelementptr [2 x i32], [2 x i32]* %68, i32 0, i32 0
  %93 = load i32, i32* %92
  store i32 %93, i32* %91
  %94 = getelementptr [2 x i32], [2 x i32]* %90, i32 0, i32 1
  store i32 1, i32* %94
  %95 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %96 = call ccc i1 @btree_insert_value_1(%btree_t_1* %95, [2 x i32]* %90)
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %84)
  br label %loop_3
range_query.end_3:
  br label %end_if_9
end_if_9:
  call ccc void @btree_iterator_next_0(%btree_iterator_t_0* %63)
  br label %loop_2
range_query.end_2:
  ret void
}
