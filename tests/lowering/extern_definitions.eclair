// RUN: split-file %s %t

// RUN: %eclair compile --emit ra-transformed %t/program.eclair > %t/actual_ra.out
// RUN: diff %t/expected_ra.out %t/actual_ra.out

// RUN: %eclair compile --emit eir %t/program.eclair > %t/actual_eir.out
// RUN: %extract_snippet %t/actual_eir.out "fn.*eclair_program_run" > %t/actual_eir_snippet.out
// RUN: diff %t/expected_eir.out %t/actual_eir_snippet.out

// RUN: %eclair compile --emit llvm %t/program.eclair > %t/actual_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "define.*@eclair_program_run" > %t/actual_llvm_snippet.out
// RUN: diff %t/expected_llvm.out %t/actual_llvm_snippet.out

//--- program.eclair
@def edge(u32, u32) input.
@def test_externs(u32) output.

@extern constraint(string).
@extern func(u32) u32.
@extern func2(u32, u32) string.

test_externs(func(123)).

test_externs(x) :-
  edge(x, _),
  constraint("abc"),
  constraint(func2(123, 456)).

test_externs(x) :-
  edge(x, y),
  x = func(123),  // This can be indexed on
  x = func(y),    // This can't, x and y defined in same relation
  "abc" = func2(456, 789).

//--- expected_ra.out
if 2 = func2(456, 789) do
  search edge as edge0 where (edge0[0] = func(123)) do
    if edge0[0] = func(edge0[1]) do
      project (edge0[0]) into test_externs
if constraint(2) != 0 do
  if constraint(func2(123, 456)) != 0 do
    search edge as edge0 do
      project (edge0[0]) into test_externs
project (func(123)) into test_externs
//--- expected_eir.out
export fn eclair_program_run(*Program) -> Void
{
  condition = (2 == func2(FN_ARG[0].0, 456, 789))
  if (condition)
  {
    lower_bound_value = edge.stack_allocate Value
    upper_bound_value = edge.stack_allocate Value
    lower_bound_value.0 = func(FN_ARG[0].0, 123)
    lower_bound_value.1 = 0
    upper_bound_value.0 = func(FN_ARG[0].0, 123)
    upper_bound_value.1 = 4294967295
    begin_iter = edge.stack_allocate Iter
    end_iter = edge.stack_allocate Iter
    edge.iter_lower_bound(FN_ARG[0].1, lower_bound_value, begin_iter)
    edge.iter_upper_bound(FN_ARG[0].1, upper_bound_value, end_iter)
    loop
    {
      condition_1 = edge.iter_is_equal(begin_iter, end_iter)
      if (condition_1)
      {
        goto range_query.end
      }
      current = edge.iter_current(begin_iter)
      condition_2 = (current.0 == func(FN_ARG[0].0, current.1))
      if (condition_2)
      {
        value = test_externs.stack_allocate Value
        value.0 = current.0
        test_externs.insert(FN_ARG[0].2, value)
      }
      edge.iter_next(begin_iter)
    }
    range_query.end:
  }
  condition_3 = (constraint(FN_ARG[0].0, 2) != 0)
  if (condition_3)
  {
    condition_4 = (constraint(FN_ARG[0].0, func2(FN_ARG[0].0, 123, 456)) != 0)
    if (condition_4)
    {
      lower_bound_value_1 = edge.stack_allocate Value
      upper_bound_value_1 = edge.stack_allocate Value
      lower_bound_value_1.0 = 0
      lower_bound_value_1.1 = 0
      upper_bound_value_1.0 = 4294967295
      upper_bound_value_1.1 = 4294967295
      begin_iter_1 = edge.stack_allocate Iter
      end_iter_1 = edge.stack_allocate Iter
      edge.iter_lower_bound(FN_ARG[0].1, lower_bound_value_1, begin_iter_1)
      edge.iter_upper_bound(FN_ARG[0].1, upper_bound_value_1, end_iter_1)
      loop
      {
        condition_5 = edge.iter_is_equal(begin_iter_1, end_iter_1)
        if (condition_5)
        {
          goto range_query.end_1
        }
        current_1 = edge.iter_current(begin_iter_1)
        value_1 = test_externs.stack_allocate Value
        value_1.0 = current_1.0
        test_externs.insert(FN_ARG[0].2, value_1)
        edge.iter_next(begin_iter_1)
      }
      range_query.end_1:
    }
  }
  value_2 = test_externs.stack_allocate Value
  value_2.0 = func(FN_ARG[0].0, 123)
  test_externs.insert(FN_ARG[0].2, value_2)
}
//--- expected_llvm.out
define external ccc void @eclair_program_run(%program* %arg_0) "wasm-export-name"="eclair_program_run" {
start:
  %0 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %1 = call ccc i32 @func2(%symbol_table* %0, i32 456, i32 789)
  %2 = icmp eq i32 2, %1
  br i1 %2, label %if_0, label %end_if_2
if_0:
  %3 = alloca [2 x i32], i32 1
  %4 = alloca [2 x i32], i32 1
  %5 = getelementptr [2 x i32], [2 x i32]* %3, i32 0, i32 0
  %6 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %7 = call ccc i32 @func(%symbol_table* %6, i32 123)
  store i32 %7, i32* %5
  %8 = getelementptr [2 x i32], [2 x i32]* %3, i32 0, i32 1
  store i32 0, i32* %8
  %9 = getelementptr [2 x i32], [2 x i32]* %4, i32 0, i32 0
  %10 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %11 = call ccc i32 @func(%symbol_table* %10, i32 123)
  store i32 %11, i32* %9
  %12 = getelementptr [2 x i32], [2 x i32]* %4, i32 0, i32 1
  store i32 4294967295, i32* %12
  %13 = alloca %btree_iterator_t_0, i32 1
  %14 = alloca %btree_iterator_t_0, i32 1
  %15 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @eclair_btree_lower_bound_0(%btree_t_0* %15, [2 x i32]* %3, %btree_iterator_t_0* %13)
  %16 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @eclair_btree_upper_bound_0(%btree_t_0* %16, [2 x i32]* %4, %btree_iterator_t_0* %14)
  br label %loop_0
loop_0:
  %17 = call ccc i1 @eclair_btree_iterator_is_equal_0(%btree_iterator_t_0* %13, %btree_iterator_t_0* %14)
  br i1 %17, label %if_1, label %end_if_0
if_1:
  br label %range_query.end
end_if_0:
  %18 = call ccc [2 x i32]* @eclair_btree_iterator_current_0(%btree_iterator_t_0* %13)
  %19 = getelementptr [2 x i32], [2 x i32]* %18, i32 0, i32 0
  %20 = load i32, i32* %19
  %21 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %22 = getelementptr [2 x i32], [2 x i32]* %18, i32 0, i32 1
  %23 = call ccc i32 @func(%symbol_table* %21, i32* %22)
  %24 = icmp eq i32 %20, %23
  br i1 %24, label %if_2, label %end_if_1
if_2:
  %25 = alloca [1 x i32], i32 1
  %26 = getelementptr [1 x i32], [1 x i32]* %25, i32 0, i32 0
  %27 = getelementptr [2 x i32], [2 x i32]* %18, i32 0, i32 0
  %28 = load i32, i32* %27
  store i32 %28, i32* %26
  %29 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %30 = call ccc i1 @eclair_btree_insert_value_1(%btree_t_1* %29, [1 x i32]* %25)
  br label %end_if_1
end_if_1:
  call ccc void @eclair_btree_iterator_next_0(%btree_iterator_t_0* %13)
  br label %loop_0
range_query.end:
  br label %end_if_2
end_if_2:
  %31 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %32 = call ccc i1 @constraint(%symbol_table* %31, i32 2)
  %33 = icmp ne i1 %32, 0
  br i1 %33, label %if_3, label %end_if_5
if_3:
  %34 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %35 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %36 = call ccc i32 @func2(%symbol_table* %35, i32 123, i32 456)
  %37 = call ccc i1 @constraint(%symbol_table* %34, i32 %36)
  %38 = icmp ne i1 %37, 0
  br i1 %38, label %if_4, label %end_if_4
if_4:
  %39 = alloca [2 x i32], i32 1
  %40 = alloca [2 x i32], i32 1
  %41 = getelementptr [2 x i32], [2 x i32]* %39, i32 0, i32 0
  store i32 0, i32* %41
  %42 = getelementptr [2 x i32], [2 x i32]* %39, i32 0, i32 1
  store i32 0, i32* %42
  %43 = getelementptr [2 x i32], [2 x i32]* %40, i32 0, i32 0
  store i32 4294967295, i32* %43
  %44 = getelementptr [2 x i32], [2 x i32]* %40, i32 0, i32 1
  store i32 4294967295, i32* %44
  %45 = alloca %btree_iterator_t_0, i32 1
  %46 = alloca %btree_iterator_t_0, i32 1
  %47 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @eclair_btree_lower_bound_0(%btree_t_0* %47, [2 x i32]* %39, %btree_iterator_t_0* %45)
  %48 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @eclair_btree_upper_bound_0(%btree_t_0* %48, [2 x i32]* %40, %btree_iterator_t_0* %46)
  br label %loop_1
loop_1:
  %49 = call ccc i1 @eclair_btree_iterator_is_equal_0(%btree_iterator_t_0* %45, %btree_iterator_t_0* %46)
  br i1 %49, label %if_5, label %end_if_3
if_5:
  br label %range_query.end_1
end_if_3:
  %50 = call ccc [2 x i32]* @eclair_btree_iterator_current_0(%btree_iterator_t_0* %45)
  %51 = alloca [1 x i32], i32 1
  %52 = getelementptr [1 x i32], [1 x i32]* %51, i32 0, i32 0
  %53 = getelementptr [2 x i32], [2 x i32]* %50, i32 0, i32 0
  %54 = load i32, i32* %53
  store i32 %54, i32* %52
  %55 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %56 = call ccc i1 @eclair_btree_insert_value_1(%btree_t_1* %55, [1 x i32]* %51)
  call ccc void @eclair_btree_iterator_next_0(%btree_iterator_t_0* %45)
  br label %loop_1
range_query.end_1:
  br label %end_if_4
end_if_4:
  br label %end_if_5
end_if_5:
  %57 = alloca [1 x i32], i32 1
  %58 = getelementptr [1 x i32], [1 x i32]* %57, i32 0, i32 0
  %59 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  %60 = call ccc i32 @func(%symbol_table* %59, i32 123)
  store i32 %60, i32* %58
  %61 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %62 = call ccc i1 @eclair_btree_insert_value_1(%btree_t_1* %61, [1 x i32]* %57)
  ret void
}
