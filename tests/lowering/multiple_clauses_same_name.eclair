// RUN: split-file %s %t

// RUN: %eclair compile --emit ra-transformed %t/program.eclair > %t/actual_ra.out
// RUN: diff %t/expected_ra.out %t/actual_ra.out

// RUN: %eclair compile --emit eir %t/program.eclair > %t/actual_eir.out
// RUN: diff %t/expected_eir.out %t/actual_eir.out

// RUN: %eclair compile --emit llvm %t/program.eclair > %t/actual_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "program = " > %t/actual_eclair_program_type.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_init" > %t/actual_eclair_program_init_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_destroy" > %t/actual_eclair_program_destroy_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "@eclair_program_run" > %t/actual_eclair_program_run_llvm.out
// RUN: diff %t/expected_eclair_program_type.out %t/actual_eclair_program_type.out
// RUN: diff %t/expected_eclair_program_init_llvm.out %t/actual_eclair_program_init_llvm.out
// RUN: diff %t/expected_eclair_program_destroy_llvm.out %t/actual_eclair_program_destroy_llvm.out
// RUN: diff %t/expected_eclair_program_run_llvm.out %t/actual_eclair_program_run_llvm.out

//--- program.eclair
@def link(u32, u32).
@def chain(u32, u32, u32) output.

link(1,2).

chain(x, y, z) :-
  link(x, y),
  link(y, z).

//--- expected_ra.out
project (1, 2) into link
search link as link0 do
  search link as link1 where (link0[1] = link1[0]) do
    project (link0[0], link0[1], link1[1]) into chain
//--- expected_eir.out
declare_type Program
{
  symbol_table
  chain btree(num_columns=3, index=[0,1,2], block_size=256, search_type=linear)
  link btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
}

export fn eclair_program_init() -> *Program
{
  program = heap_allocate_program
  symbol_table.init(program.0)
  chain.init_empty(program.1)
  link.init_empty(program.2)
  symbol_table.insert(program.0, link)
  symbol_table.insert(program.0, chain)
  return program
}

export fn eclair_program_destroy(*Program) -> Void
{
  symbol_table.destroy(FN_ARG[0].0)
  chain.destroy(FN_ARG[0].1)
  link.destroy(FN_ARG[0].2)
  free_program(FN_ARG[0])
}

export fn eclair_program_run(*Program) -> Void
{
  value = link.stack_allocate Value
  value.0 = 1
  value.1 = 2
  link.insert(FN_ARG[0].2, value)
  lower_bound_value = link.stack_allocate Value
  upper_bound_value = link.stack_allocate Value
  lower_bound_value.0 = 0
  lower_bound_value.1 = 0
  upper_bound_value.0 = 4294967295
  upper_bound_value.1 = 4294967295
  begin_iter = link.stack_allocate Iter
  end_iter = link.stack_allocate Iter
  link.iter_lower_bound(FN_ARG[0].2, lower_bound_value, begin_iter)
  link.iter_upper_bound(FN_ARG[0].2, upper_bound_value, end_iter)
  loop
  {
    condition = link.iter_is_equal(begin_iter, end_iter)
    if (condition)
    {
      goto range_query.end
    }
    current = link.iter_current(begin_iter)
    lower_bound_value_1 = link.stack_allocate Value
    upper_bound_value_1 = link.stack_allocate Value
    lower_bound_value_1.0 = current.1
    lower_bound_value_1.1 = 0
    upper_bound_value_1.0 = current.1
    upper_bound_value_1.1 = 4294967295
    begin_iter_1 = link.stack_allocate Iter
    end_iter_1 = link.stack_allocate Iter
    link.iter_lower_bound(FN_ARG[0].2, lower_bound_value_1, begin_iter_1)
    link.iter_upper_bound(FN_ARG[0].2, upper_bound_value_1, end_iter_1)
    loop
    {
      condition_1 = link.iter_is_equal(begin_iter_1, end_iter_1)
      if (condition_1)
      {
        goto range_query.end_1
      }
      current_1 = link.iter_current(begin_iter_1)
      value_1 = chain.stack_allocate Value
      value_1.0 = current.0
      value_1.1 = current.1
      value_1.2 = current_1.1
      chain.insert(FN_ARG[0].1, value_1)
      link.iter_next(begin_iter_1)
    }
    range_query.end_1:
    link.iter_next(begin_iter)
  }
  range_query.end:
}
//--- expected_eclair_program_type.out
%program = type {%symbol_table, %btree_t_0, %btree_t_1}
//--- expected_eclair_program_init_llvm.out
define external ccc %program* @eclair_program_init() "wasm-export-name"="eclair_program_init" {
start:
  %0 = call ccc i8* @malloc(i32 1592)
  %1 = bitcast i8* %0 to %program*
  %2 = getelementptr %program, %program* %1, i32 0, i32 0
  call ccc void @symbol_table_init(%symbol_table* %2)
  %3 = getelementptr %program, %program* %1, i32 0, i32 1
  call ccc void @btree_init_empty_0(%btree_t_0* %3)
  %4 = getelementptr %program, %program* %1, i32 0, i32 2
  call ccc void @btree_init_empty_1(%btree_t_1* %4)
  %5 = getelementptr %program, %program* %1, i32 0, i32 0
  %6 = getelementptr inbounds [5 x i8], [5 x i8]* @string_literal_0, i32 0, i32 0
  %7 = zext i32 4 to i64
  %8 = call ccc i8* @malloc(i32 4)
  call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %6, i64 %7, i1 0)
  %9 = alloca %symbol_t, i32 1
  call ccc void @symbol_init(%symbol_t* %9, i32 4, i8* %8)
  %10 = call ccc i32 @symbol_table_find_or_insert(%symbol_table* %5, %symbol_t* %9)
  %11 = getelementptr %program, %program* %1, i32 0, i32 0
  %12 = getelementptr inbounds [6 x i8], [6 x i8]* @string_literal_1, i32 0, i32 0
  %13 = zext i32 5 to i64
  %14 = call ccc i8* @malloc(i32 5)
  call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %12, i64 %13, i1 0)
  %15 = alloca %symbol_t, i32 1
  call ccc void @symbol_init(%symbol_t* %15, i32 5, i8* %14)
  %16 = call ccc i32 @symbol_table_find_or_insert(%symbol_table* %11, %symbol_t* %15)
  ret %program* %1
}
//--- expected_eclair_program_destroy_llvm.out
define external ccc void @eclair_program_destroy(%program* %arg_0) "wasm-export-name"="eclair_program_destroy" {
start:
  %0 = getelementptr %program, %program* %arg_0, i32 0, i32 0
  call ccc void @symbol_table_destroy(%symbol_table* %0)
  %1 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  call ccc void @btree_destroy_0(%btree_t_0* %1)
  %2 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_destroy_1(%btree_t_1* %2)
  %3 = bitcast %program* %arg_0 to i8*
  call ccc void @free(i8* %3)
  ret void
}
//--- expected_eclair_program_run_llvm.out
define external ccc void @eclair_program_run(%program* %arg_0) "wasm-export-name"="eclair_program_run" {
start:
  %0 = alloca [2 x i32], i32 1
  %1 = getelementptr [2 x i32], [2 x i32]* %0, i32 0, i32 0
  store i32 1, i32* %1
  %2 = getelementptr [2 x i32], [2 x i32]* %0, i32 0, i32 1
  store i32 2, i32* %2
  %3 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  %4 = call ccc i1 @btree_insert_value_1(%btree_t_1* %3, [2 x i32]* %0)
  %5 = alloca [2 x i32], i32 1
  %6 = alloca [2 x i32], i32 1
  %7 = getelementptr [2 x i32], [2 x i32]* %5, i32 0, i32 0
  store i32 0, i32* %7
  %8 = getelementptr [2 x i32], [2 x i32]* %5, i32 0, i32 1
  store i32 0, i32* %8
  %9 = getelementptr [2 x i32], [2 x i32]* %6, i32 0, i32 0
  store i32 4294967295, i32* %9
  %10 = getelementptr [2 x i32], [2 x i32]* %6, i32 0, i32 1
  store i32 4294967295, i32* %10
  %11 = alloca %btree_iterator_t_1, i32 1
  %12 = alloca %btree_iterator_t_1, i32 1
  %13 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_lower_bound_1(%btree_t_1* %13, [2 x i32]* %5, %btree_iterator_t_1* %11)
  %14 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_upper_bound_1(%btree_t_1* %14, [2 x i32]* %6, %btree_iterator_t_1* %12)
  br label %loop_0
loop_0:
  %15 = call ccc i1 @btree_iterator_is_equal_1(%btree_iterator_t_1* %11, %btree_iterator_t_1* %12)
  br i1 %15, label %if_0, label %end_if_0
if_0:
  br label %range_query.end
end_if_0:
  %16 = call ccc [2 x i32]* @btree_iterator_current_1(%btree_iterator_t_1* %11)
  %17 = alloca [2 x i32], i32 1
  %18 = alloca [2 x i32], i32 1
  %19 = getelementptr [2 x i32], [2 x i32]* %17, i32 0, i32 0
  %20 = getelementptr [2 x i32], [2 x i32]* %16, i32 0, i32 1
  %21 = load i32, i32* %20
  store i32 %21, i32* %19
  %22 = getelementptr [2 x i32], [2 x i32]* %17, i32 0, i32 1
  store i32 0, i32* %22
  %23 = getelementptr [2 x i32], [2 x i32]* %18, i32 0, i32 0
  %24 = getelementptr [2 x i32], [2 x i32]* %16, i32 0, i32 1
  %25 = load i32, i32* %24
  store i32 %25, i32* %23
  %26 = getelementptr [2 x i32], [2 x i32]* %18, i32 0, i32 1
  store i32 4294967295, i32* %26
  %27 = alloca %btree_iterator_t_1, i32 1
  %28 = alloca %btree_iterator_t_1, i32 1
  %29 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_lower_bound_1(%btree_t_1* %29, [2 x i32]* %17, %btree_iterator_t_1* %27)
  %30 = getelementptr %program, %program* %arg_0, i32 0, i32 2
  call ccc void @btree_upper_bound_1(%btree_t_1* %30, [2 x i32]* %18, %btree_iterator_t_1* %28)
  br label %loop_1
loop_1:
  %31 = call ccc i1 @btree_iterator_is_equal_1(%btree_iterator_t_1* %27, %btree_iterator_t_1* %28)
  br i1 %31, label %if_1, label %end_if_1
if_1:
  br label %range_query.end_1
end_if_1:
  %32 = call ccc [2 x i32]* @btree_iterator_current_1(%btree_iterator_t_1* %27)
  %33 = alloca [3 x i32], i32 1
  %34 = getelementptr [3 x i32], [3 x i32]* %33, i32 0, i32 0
  %35 = getelementptr [2 x i32], [2 x i32]* %16, i32 0, i32 0
  %36 = load i32, i32* %35
  store i32 %36, i32* %34
  %37 = getelementptr [3 x i32], [3 x i32]* %33, i32 0, i32 1
  %38 = getelementptr [2 x i32], [2 x i32]* %16, i32 0, i32 1
  %39 = load i32, i32* %38
  store i32 %39, i32* %37
  %40 = getelementptr [3 x i32], [3 x i32]* %33, i32 0, i32 2
  %41 = getelementptr [2 x i32], [2 x i32]* %32, i32 0, i32 1
  %42 = load i32, i32* %41
  store i32 %42, i32* %40
  %43 = getelementptr %program, %program* %arg_0, i32 0, i32 1
  %44 = call ccc i1 @btree_insert_value_0(%btree_t_0* %43, [3 x i32]* %33)
  call ccc void @btree_iterator_next_1(%btree_iterator_t_1* %27)
  br label %loop_1
range_query.end_1:
  call ccc void @btree_iterator_next_1(%btree_iterator_t_1* %11)
  br label %loop_0
range_query.end:
  ret void
}
