// RUN: split-file %s %t

// RUN: %eclair compile --emit ra %t/program.eclair > %t/actual_ra.out
// RUN: diff %t/expected_ra.out %t/actual_ra.out

// RUN: %eclair compile --emit eir %t/program.eclair > %t/actual_eir.out
// RUN: diff %t/expected_eir.out %t/actual_eir.out

//--- program.eclair
@def edge(u32, u32).
@def another(u32, u32, u32).

edge(1, 2).
edge(2, 3).

another(1,2,3).

//--- expected_ra.out
project (1, 2, 3) into another
project (2, 3) into edge
project (1, 2) into edge
//--- expected_eir.out
declare_type Program
{
  symbol_table
  another btree(num_columns=3, index=[0,1,2], block_size=256, search_type=linear)
  edge btree(num_columns=2, index=[0,1], block_size=256, search_type=linear)
}

fn eclair_program_init() -> *Program
{
  program = heap_allocate_program
  symbol_table.init(program.0)
  another.init_empty(program.1)
  edge.init_empty(program.2)
  return program
}

fn eclair_program_destroy(*Program) -> Void
{
  symbol_table.destroy(FN_ARG[0].0)
  another.destroy(FN_ARG[0].1)
  edge.destroy(FN_ARG[0].2)
  free_program(FN_ARG[0])
}

fn eclair_program_run(*Program) -> Void
{
  value = another.stack_allocate Value
  value.0 = 1
  value.1 = 2
  value.2 = 3
  another.insert(FN_ARG[0].1, value)
  value_1 = edge.stack_allocate Value
  value_1.0 = 2
  value_1.1 = 3
  edge.insert(FN_ARG[0].2, value_1)
  value_2 = edge.stack_allocate Value
  value_2.0 = 1
  value_2.1 = 2
  edge.insert(FN_ARG[0].2, value_2)
}
