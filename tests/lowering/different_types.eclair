// TODO add tests for caching mechanism (e.g. single_nonrecursive_rule test)

// RUN: split-file %s %t

// RUN: %eclair compile --emit llvm %t/program.eclair > %t/actual_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "define.*@eclair_add_facts" > %t/actual_eclair_add_facts_llvm.out
// RUN: %extract_snippet %t/actual_llvm.out "define.*@eclair_get_facts" > %t/actual_eclair_get_facts_llvm.out
// RUN: diff %t/expected_eclair_add_facts_llvm.out %t/actual_eclair_add_facts_llvm.out
// RUN: diff %t/expected_eclair_get_facts_llvm.out %t/actual_eclair_get_facts_llvm.out

//--- program.eclair
@def a(u32) input output.
@def b(u32, u32, u32) input output.

//--- expected_eclair_add_facts_llvm.out
define external ccc void @eclair_add_facts(%program* %eclair_program_0, i32 %fact_type_0, i32* %memory_0, i32 %fact_count_0) "wasm-export-name"="eclair_add_facts" {
start:
  switch i32 %fact_type_0, label %switch.default_0 [i32 0, label %a_0 i32 1, label %b_0]
a_0:
  %0 = getelementptr %program, %program* %eclair_program_0, i32 0, i32 1
  %1 = bitcast i32* %memory_0 to [1 x i32]*
  br label %for_begin_0
for_begin_0:
  %2 = phi i32 [0, %a_0], [%6, %for_body_0]
  %3 = icmp ult i32 %2, %fact_count_0
  br i1 %3, label %for_body_0, label %for_end_0
for_body_0:
  %4 = getelementptr [1 x i32], [1 x i32]* %1, i32 %2
  %5 = call ccc i1 @eclair_btree_insert_value_0(%btree_t_0* %0, [1 x i32]* %4)
  %6 = add i32 1, %2
  br label %for_begin_0
for_end_0:
  ret void
b_0:
  %7 = getelementptr %program, %program* %eclair_program_0, i32 0, i32 2
  %8 = bitcast i32* %memory_0 to [3 x i32]*
  br label %for_begin_1
for_begin_1:
  %9 = phi i32 [0, %b_0], [%13, %for_body_1]
  %10 = icmp ult i32 %9, %fact_count_0
  br i1 %10, label %for_body_1, label %for_end_1
for_body_1:
  %11 = getelementptr [3 x i32], [3 x i32]* %8, i32 %9
  %12 = call ccc i1 @eclair_btree_insert_value_1(%btree_t_1* %7, [3 x i32]* %11)
  %13 = add i32 1, %9
  br label %for_begin_1
for_end_1:
  ret void
switch.default_0:
  ret void
}
//--- expected_eclair_get_facts_llvm.out
define external ccc i32* @eclair_get_facts(%program* %eclair_program_0, i32 %fact_type_0) "wasm-export-name"="eclair_get_facts" {
start:
  %stack.ptr_0 = alloca i32, i32 1
  %stack.ptr_1 = alloca %btree_iterator_t_0, i32 1
  %stack.ptr_2 = alloca %btree_iterator_t_0, i32 1
  %stack.ptr_3 = alloca i32, i32 1
  %stack.ptr_4 = alloca %btree_iterator_t_1, i32 1
  %stack.ptr_5 = alloca %btree_iterator_t_1, i32 1
  switch i32 %fact_type_0, label %switch.default_0 [i32 0, label %a_0 i32 1, label %b_0]
a_0:
  %0 = getelementptr %program, %program* %eclair_program_0, i32 0, i32 1
  %1 = call ccc i64 @eclair_btree_size_0(%btree_t_0* %0)
  %2 = trunc i64 %1 to i32
  %3 = mul i32 %2, 4
  %4 = call ccc i8* @malloc(i32 %3)
  %5 = bitcast i8* %4 to [1 x i32]*
  store i32 0, i32* %stack.ptr_0
  call ccc void @eclair_btree_begin_0(%btree_t_0* %0, %btree_iterator_t_0* %stack.ptr_1)
  call ccc void @eclair_btree_end_0(%btree_t_0* %0, %btree_iterator_t_0* %stack.ptr_2)
  br label %while_begin_0
while_begin_0:
  %6 = call ccc i1 @eclair_btree_iterator_is_equal_0(%btree_iterator_t_0* %stack.ptr_1, %btree_iterator_t_0* %stack.ptr_2)
  %7 = select i1 %6, i1 0, i1 1
  br i1 %7, label %while_body_0, label %while_end_0
while_body_0:
  %8 = load i32, i32* %stack.ptr_0
  %9 = getelementptr [1 x i32], [1 x i32]* %5, i32 %8
  %10 = call ccc [1 x i32]* @eclair_btree_iterator_current_0(%btree_iterator_t_0* %stack.ptr_1)
  %11 = getelementptr [1 x i32], [1 x i32]* %10, i32 0
  %12 = load [1 x i32], [1 x i32]* %11
  %13 = getelementptr [1 x i32], [1 x i32]* %9, i32 0
  store [1 x i32] %12, [1 x i32]* %13
  %14 = add i32 %8, 1
  store i32 %14, i32* %stack.ptr_0
  call ccc void @eclair_btree_iterator_next_0(%btree_iterator_t_0* %stack.ptr_1)
  br label %while_begin_0
while_end_0:
  %15 = bitcast i8* %4 to i32*
  ret i32* %15
b_0:
  %16 = getelementptr %program, %program* %eclair_program_0, i32 0, i32 2
  %17 = call ccc i64 @eclair_btree_size_1(%btree_t_1* %16)
  %18 = trunc i64 %17 to i32
  %19 = mul i32 %18, 12
  %20 = call ccc i8* @malloc(i32 %19)
  %21 = bitcast i8* %20 to [3 x i32]*
  store i32 0, i32* %stack.ptr_3
  call ccc void @eclair_btree_begin_1(%btree_t_1* %16, %btree_iterator_t_1* %stack.ptr_4)
  call ccc void @eclair_btree_end_1(%btree_t_1* %16, %btree_iterator_t_1* %stack.ptr_5)
  br label %while_begin_1
while_begin_1:
  %22 = call ccc i1 @eclair_btree_iterator_is_equal_1(%btree_iterator_t_1* %stack.ptr_4, %btree_iterator_t_1* %stack.ptr_5)
  %23 = select i1 %22, i1 0, i1 1
  br i1 %23, label %while_body_1, label %while_end_1
while_body_1:
  %24 = load i32, i32* %stack.ptr_3
  %25 = getelementptr [3 x i32], [3 x i32]* %21, i32 %24
  %26 = call ccc [3 x i32]* @eclair_btree_iterator_current_1(%btree_iterator_t_1* %stack.ptr_4)
  %27 = getelementptr [3 x i32], [3 x i32]* %26, i32 0
  %28 = load [3 x i32], [3 x i32]* %27
  %29 = getelementptr [3 x i32], [3 x i32]* %25, i32 0
  store [3 x i32] %28, [3 x i32]* %29
  %30 = add i32 %24, 1
  store i32 %30, i32* %stack.ptr_3
  call ccc void @eclair_btree_iterator_next_1(%btree_iterator_t_1* %stack.ptr_4)
  br label %while_begin_1
while_end_1:
  %31 = bitcast i8* %20 to i32*
  ret i32* %31
switch.default_0:
  ret i32* zeroinitializer
}
