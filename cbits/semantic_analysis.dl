.decl literal(node_id: unsigned, value: unsigned)
.decl variable(node_id: unsigned, var_name: symbol)
.decl atom(node_id: unsigned, name: symbol)
.decl atom_arg(atom_id: unsigned, atom_arg_pos: unsigned, atom_arg_id: unsigned)
.decl rule(rule_id: unsigned, name: symbol)
.decl rule_arg(rule_id: unsigned, rule_arg_pos: unsigned, rule_arg_id: unsigned)
.decl rule_clause(rule_id: unsigned, rule_clause_pos: unsigned, rule_clause_id: unsigned)
.decl declare_type(node_id: unsigned, name: symbol)
.decl module(node_id: unsigned)
.decl module_declaration(module_id: unsigned, declaration_id: unsigned)

.decl wildcard(node_id: unsigned) inline
.decl rule_clause_var(rule_id: unsigned, var_name: symbol)

.decl ungrounded_variable(node_id: unsigned, var_name: symbol)
.decl missing_typedef(node_id: unsigned, var_name: symbol)
.decl empty_module(node_id: unsigned)
.decl rule_clause_same_var(rule_clause_id: unsigned, var_name: symbol)
.decl wildcard_in_fact(fact_node_id: unsigned,  fact_arg_id: unsigned, pos: unsigned)
.decl wildcard_in_rule_head(rule_node_id: unsigned, rule_arg_id: unsigned, pos: unsigned)


.input literal
.input variable
.input atom
.input atom_arg
.input rule
.input rule_arg
.input rule_clause
.input declare_type
.input module
.input module_declaration

.output ungrounded_variable
.output missing_typedef
.output empty_module
.output rule_clause_same_var
.output wildcard_in_fact
.output wildcard_in_rule_head

// Top level facts: no variables allowed
ungrounded_variable(atom_arg_id, var_name) :-
  module_declaration(_, atom_id),
  atom_arg(atom_id, _, atom_arg_id),
  variable(atom_arg_id, var_name).

// Rules: no variables allowed in rule head if not used in rule body
ungrounded_variable(rule_arg_id, var_name) :-
  rule(rule_id, _),
  rule_arg(rule_id, _, rule_arg_id),
  variable(rule_arg_id, var_name),
  !rule_clause_var(rule_id, var_name).

// Helper relation for getting all variables in body of a rule.
rule_clause_var(rule_id, var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  atom_arg(rule_clause_id, _, var_id),
  variable(var_id, var_name).

// Currently not supported (though planned for the future): facts with same var occurring >1 times.
// This would require an extra equality constraint, which is not supported atm.
rule_clause_same_var(rule_clause_id, var) :-
  rule_clause(_, _, rule_clause_id),
  atom_arg(rule_clause_id, pos1, atom_arg_id1),
  atom_arg(rule_clause_id, pos2, atom_arg_id2),
  pos1 != pos2,
  variable(atom_arg_id1, var),
  variable(atom_arg_id2, var).

// An atom always needs a type definition
missing_typedef(node_id, atom_name) :-
  atom(node_id, atom_name),
  !declare_type(_, atom_name).

// A rule always needs a type definition
missing_typedef(node_id, rule_name) :-
  rule(node_id, rule_name),
  !declare_type(_, rule_name).

empty_module(node_id) :-
  module(node_id),
  !module_declaration(node_id, _).

wildcard(node_id) :-
  variable(node_id, "_").

wildcard_in_rule_head(rule_id, rule_arg_id, pos) :-
  rule_arg(rule_id, pos, rule_arg_id),
  wildcard(rule_arg_id).

wildcard_in_fact(atom_id, atom_arg_id, pos) :-
  module_declaration(_, atom_id),
  atom_arg(atom_id, pos, atom_arg_id),
  wildcard(atom_arg_id).
