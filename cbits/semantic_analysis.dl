// Input facts
.decl lit_number(node_id: unsigned, value: unsigned)
.decl lit_string(node_id: unsigned, value: symbol)
.decl variable(node_id: unsigned, var_name: symbol)
.decl constraint(node_id: unsigned, op: symbol, lhs_node_id: unsigned, rhs_node_id: unsigned)
.decl atom(node_id: unsigned, name: symbol)
.decl atom_arg(atom_id: unsigned, atom_arg_pos: unsigned, atom_arg_id: unsigned)
.decl rule(rule_id: unsigned, name: symbol)
.decl rule_arg(rule_id: unsigned, rule_arg_pos: unsigned, rule_arg_id: unsigned)
.decl rule_clause(rule_id: unsigned, rule_clause_pos: unsigned, rule_clause_id: unsigned)
.decl input_relation(relation_name: symbol)
.decl output_relation(relation_name: symbol)
.decl internal_relation(relation_name: symbol)
.decl declare_type(node_id: unsigned, name: symbol)
.decl module(node_id: unsigned)
.decl module_declaration(module_id: unsigned, declaration_id: unsigned)
.decl rule_variable(rule_id: unsigned, variable_id: unsigned)

// Internal rules
.decl assign(node_id: unsigned, lhs_node_id: unsigned, rhs_node_id: unsigned) inline
.decl inequality_op(op: symbol)
.decl has_output_relation(node_id: unsigned)
.decl literal_contradiction(lit_id1: unsigned, lit_id2: unsigned)
.decl wildcard(node_id: unsigned) inline
.decl rule_head_var(rule_id: unsigned, var_id: unsigned, var_name: symbol)
.decl grounded_var(rule_id: unsigned, var_name: symbol)
.decl alias(rule_id: unsigned, id1: unsigned, id2: unsigned)
.decl points_to(rule_id: unsigned, id1: unsigned, id2: unsigned)
.decl depends_on(r1: symbol, r2: symbol)
.decl transitive_depends_on(r1: symbol, r2: symbol)
.decl source(r: symbol)
.decl has_definitions(relation: symbol)
.decl live_rule(relation: symbol)

// Output facts / rules
.decl points_to_var(rule_id: unsigned, var_id1: unsigned, var_id2: unsigned, var_name: symbol)
.decl variable_in_fact(node_id: unsigned, var_name: symbol)
.decl ungrounded_variable(rule_id: unsigned, var_id: unsigned, var_name: symbol)
.decl wildcard_in_fact(fact_node_id: unsigned,  fact_arg_id: unsigned, pos: unsigned)
.decl wildcard_in_rule_head(rule_node_id: unsigned, rule_arg_id: unsigned, pos: unsigned)
.decl wildcard_in_constraint(constraint_node_id: unsigned, wildcard_node_id: unsigned)
.decl rule_with_contradiction(rule_id: unsigned)
.decl dead_code(node_id: unsigned)
.decl no_output_relation(node_id: unsigned)
.decl dead_internal_relation(node_id: unsigned, relation_name: symbol)

.input lit_number
.input lit_string
.input variable
.input constraint
.input atom
.input atom_arg
.input rule
.input rule_arg
.input rule_clause
.input input_relation
.input output_relation
.input internal_relation
.input declare_type
.input module
.input module_declaration
.input rule_variable

.output points_to_var
.output variable_in_fact
.output wildcard_in_fact
.output ungrounded_variable
.output wildcard_in_rule_head
.output wildcard_in_constraint
.output dead_code
.output no_output_relation
.output dead_internal_relation

// r1 depends on r2 if rule r1 refers to r2 in the body
depends_on(r1, r2) :-
  rule(rule_id, r1),
  rule_clause(rule_id, _, clause_id),
  atom(clause_id, r2).

transitive_depends_on(r1, r2) :-
  depends_on(r1, r2).

transitive_depends_on(r1, r3) :-
  depends_on(r1, r2),
  transitive_depends_on(r2, r3).

// An input can always be a source of data.
source(r) :-
  input_relation(r).

// An internal or output relation can be a source of data if they define top level facts.
source(r) :-
  module_declaration(_, atom_id),
  atom(atom_id, r),
  !input_relation(r).  // internal or output relation

// An output rule is live if it is a direct source of data.
live_rule(r) :-
  output_relation(r),
  source(r).

// An output rule is live if there is a path from the source to this output.
live_rule(r1) :-
  output_relation(r1),
  transitive_depends_on(r1, r2),
  source(r2).

// A rule is live if it is depended on by another live rule.
live_rule(r2) :-
  depends_on(r1, r2),
  live_rule(r1).

// Dead rules are the opposite set of all the live rules.
dead_code(node_id) :-
  rule(node_id, r),
  !live_rule(r).

// Type definitions also need to be marked as dead.
dead_code(node_id) :-
  declare_type(node_id, r),
  !live_rule(r).

// Atoms too.
dead_code(node_id) :-
  atom(node_id, r),
  !live_rule(r).

// Rules are dead if one of the clauses is statically known to produce no results.
dead_code(rule_id) :-
  rule_with_contradiction(rule_id).

// A rule is dead if it depends on another dead rule.
// Note that this only looks at one specific rule that contains the dead code, not the entire relation.
dead_code(rule_id) :-
  rule_clause(rule_id, _, rule_clause_id),
  dead_code(rule_clause_id).

has_definitions(r) :-
  (module_declaration(_, atom_id), atom(atom_id, r));
  depends_on(r, _).

// An internal relation is dead if there are no top level atoms and it doesn't depend on anything.
dead_internal_relation(decl_id, r) :-
  internal_relation(r),
  declare_type(decl_id, r),
  !has_definitions(r).

// TODO which one of these are errors, which are ok to be optimized?

has_output_relation(node_id) :-
  module_declaration(node_id, decl_id),
  declare_type(decl_id, r),
  output_relation(r).

no_output_relation(node_id) :-
  module_declaration(node_id, _),
  !has_output_relation(node_id).

// Top level facts: no variables allowed
variable_in_fact(atom_arg_id, var_name) :-
  module_declaration(_, atom_id),
  atom_arg(atom_id, _, atom_arg_id),
  variable(atom_arg_id, var_name),
  var_name != "_".

// Rules: no variables allowed in rule head if not used in a rule clause
ungrounded_variable(rule_id, var_id, var_name) :-
  rule_head_var(rule_id, var_id, var_name),
  var_name != "_",
  !grounded_var(rule_id, var_name).  // Only compare by variable name!

// Variables used in a constraint (comparison or inequality) need to be grounded.
ungrounded_variable(rule_id, var_id, var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  constraint(rule_clause_id, op, var_id, _),
  inequality_op(op),
  variable(var_id, var_name),
  !grounded_var(rule_id, var_name).

ungrounded_variable(rule_id, var_id, var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  constraint(rule_clause_id, op, _, var_id),
  inequality_op(op),
  variable(var_id, var_name),
  !grounded_var(rule_id, var_name).

inequality_op("!=").
inequality_op("<").
inequality_op("<=").
inequality_op(">").
inequality_op(">=").

wildcard(node_id) :-
  variable(node_id, "_").

wildcard_in_rule_head(rule_id, rule_arg_id, pos) :-
  rule_arg(rule_id, pos, rule_arg_id),
  wildcard(rule_arg_id).

wildcard_in_fact(atom_id, atom_arg_id, pos) :-
  module_declaration(_, atom_id),
  atom_arg(atom_id, pos, atom_arg_id),
  wildcard(atom_arg_id).

wildcard_in_constraint(constraint_node_id, lhs_node_id) :-
  constraint(constraint_node_id, _, lhs_node_id, _),
  wildcard(lhs_node_id).

wildcard_in_constraint(constraint_node_id, rhs_node_id) :-
  constraint(constraint_node_id, _, _, rhs_node_id),
  wildcard(rhs_node_id).

assign(node_id, lhs_node_id, rhs_node_id) :-
  constraint(node_id, "=", lhs_node_id, rhs_node_id).

// All variables with the same name in a rule are aliases of each other.
alias(rule_id, var_id1, var_id2) :-
  rule_variable(rule_id, var_id1),
  rule_variable(rule_id, var_id2),
  variable(var_id1, var_name),
  variable(var_id2, var_name).

// Two values are aliases if they are used inside an equality.
// NOTE: Datalog supports both x = 123 and 123 = x.
alias(rule_id, id1, id2),
alias(rule_id, id2, id1) :-
  rule_clause(rule_id, _, rule_clause_id),
  assign(rule_clause_id, id1, id2).

// Non-recursive case: what does a variable point to?
points_to(rule_id, id1, id2) :-
  alias(rule_id, id1, id2),
  variable(id1, _).

// Recursive case: a = b, b = c results in a = c
points_to(rule_id, id1, id4) :-
  points_to(rule_id, id1, id2),
  variable(id2, var_name),
  variable(id3, var_name),
  alias(rule_id, id3, id4).

// NOTE: right now only takes variables into account, not literals (enhancement for later).
points_to_var(rule_id, id1, id2, var_name) :-
  points_to(rule_id, id1, id2),
  variable(id2, var_name).

// If we find two variables that point to different literal values,
// then there is a contradiction.
rule_with_contradiction(rule_id) :-
  points_to(rule_id, start_id, id1),
  points_to(rule_id, start_id, id2),
  literal_contradiction(id1, id2).

// This is also true for simple cases like '123 = 456'.
rule_with_contradiction(rule_id) :-
  rule_clause(rule_id, _, rule_clause_id),
  assign(rule_clause_id, id1, id2),
  literal_contradiction(id1, id2).

literal_contradiction(id1, id2) :-
  lit_number(id1, value1),
  lit_number(id2, value2),
  value1 != value2.

literal_contradiction(id1, id2) :-
  lit_string(id1, value1),
  lit_string(id2, value2),
  value1 != value2.


// Helper relation for getting all grounded variables in head of a rule.
rule_head_var(rule_id, var_id, var_name) :-
  rule_arg(rule_id, _, var_id),
  variable(var_id, var_name).

// Helper relation for getting all grounded variables in body of a rule.
grounded_var(rule_id, var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  atom_arg(rule_clause_id, _, var_id),
  variable(var_id, var_name).

// Assignment grounds one var, if the other is already grounded.
grounded_var(rule_id, rhs_var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  assign(rule_clause_id, lhs_node_id, rhs_node_id),
  variable(lhs_node_id, lhs_var_name),
  variable(rhs_node_id, rhs_var_name),
  grounded_var(rule_id, lhs_var_name).

grounded_var(rule_id, rhs_var_name) :-
  rule_clause(rule_id, _, rule_clause_id),
  assign(rule_clause_id, lhs_node_id, rhs_node_id),
  variable(lhs_node_id, lhs_var_name),
  variable(rhs_node_id, rhs_var_name),
  grounded_var(rule_id, rhs_var_name).
